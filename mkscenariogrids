#!/usr/bin/env python

import os
import argparse
import warnings

import numpy as np


#-------------------------------------------------------------------------------
# Openquake utilities
from openquake.hazardlib import imt, const

from mapio.geodict import GeoDict
from mapio.gmt import GMTGrid

# Shakemap imports
import shakemap.grind.fault as fault
from shakemap.grind.source import Source
from shakemap.grind.distance import Distance
from shakemap.grind.sites import Sites
from shakemap.grind.multigmpe import MultiGMPE
from shakemap.grind.directivity.rowshandel2013 import Rowshandel2013
from shakemap.utils.timeutils import ShakeDateTime
from shakemap.grind.gmice.wgrw12 import WGRW12
from shakemap.grind.virtualipe import VirtualIPE
from shakemap.grind.gmpe_sets import nshmp14_acr
from shakemap.grind.gmpe_sets import nshmp14_scr_rlme
from shakemap.grind.gmpe_sets import nshmp14_scr_grd
from shakemap.grind.gmpe_sets import nshmp14_sub_i
from shakemap.grind.gmpe_sets import nshmp14_sub_s

from impactutils.io.cmd import get_command_output

from scenarios.utils import filter_gmpe_list
from scenarios.utils import is_stable
from scenarios.utils import get_extent
from scenarios.input_output import read_event_xml


def main(args):
    id_str = args.event
    if args.shakehome:
        shakehome = args.shakehome
    else:
        shakehome = os.path.join(os.path.expanduser('~'), 'ShakeMap')
    datdir = os.path.join(shakehome, 'data')
    evt_dir = os.path.join(datdir, id_str)
    input_dir = os.path.join(evt_dir, 'input')
    xml_file = os.path.join(input_dir, 'event.xml')

    #---------------------------------------------------------------------------
    # Read in event.xml
    #---------------------------------------------------------------------------
    event = read_event_xml(xml_file)

    #---------------------------------------------------------------------------
    # Read in rupture and make event dictionary
    #---------------------------------------------------------------------------
    cmd = 'ls %s/*fault-for-calc.txt' % (input_dir)
    rc, so, se = get_command_output(cmd)

    # probably need to add some error checking here

    ruptfile = so.decode('utf-8').strip()
    flt = fault.Fault.readFaultFile(ruptfile)

    #---------------------------------------------------------------------------
    # Get list of GMPEs
    #---------------------------------------------------------------------------

    if args.gmpe == 'NSHMP14shallow':
        # Select between SCR and ACR
        stable = is_stable(event['lon'], event['lat'])
        
        # if SCR check for fault
        
    elif args.gmpe == 'NSHMP14acr':
        gmpes, wts, wts_large_dist, dist_cutoff, site_gmpes = \
            nshmp14_acr.get_weights()
    elif args.gmpe == 'NSHMP14scr_rlme':
        gmpes, wts, wts_large_dist, dist_cutoff, site_gmpes = \
            nshmp14_scr_rlme.get_weights()
    elif args.gmpe == 'NSHMP14scr_grd':
        gmpes, wts, wts_large_dist, dist_cutoff, site_gmpes = \
            nshmp14_scr_grd.get_weights()
    elif args.gmpe == 'NSHMPsub_i':
        gmpes, wts, wts_large_dist, dist_cutoff, site_gmpes = \
            nshmp14_sub_i.get_weights()
    elif args.gmpe == 'NSHMPsub_s':
        gmpes, wts, wts_large_dist, dist_cutoff, site_gmpes = \
            nshmp14_sub_s.get_weights()
    else:
        raise Exception('Specified an unsupported GMPE.')

    #---------------------------------------------------------------------------
    # Make source instance and compute extent
    #---------------------------------------------------------------------------
    source = Source(event, flt)

    lonmin, lonmax, latmin, latmax = get_extent(source)

    # Adjust extent to be divisible by resolution
    res = args.res
    lonmin = res * np.round(lonmin / res)
    lonmax = res * np.round(lonmax / res)
    latmin = res * np.round(latmin / res)
    latmax = res * np.round(latmax / res)

    lonspan = float(lonmax - lonmin)
    latspan = float(latmax - latmin)

    # Adjust number of cells if necessary
    nx = np.floor(lonspan / res) + 1
    ny = np.floor(latspan / res) + 1
    ncell = nx * ny
    nmax = args.max
    if ncell > nmax:
        res = (-(latspan + lonspan) -
               np.sqrt(latspan**2 + lonspan**2 + 2 * latspan * lonspan *\
                       (2 * nmax - 1))) /(2 * (1 - nmax))
        warnings.warn(
            'resolution adjusted due to max number of cells allowed.')
        nx = np.floor(lonspan / res) + 1
        ny = np.floor(latspan / res) + 1
        ncell = nx * ny

    # buffer to increase grid so that it doesn't barf when sent to ShakeMap
#    buf = 2 * res

    # Geodictionary for this ShakeMap
    tmpdict = {'xmin': lonmin, 'xmax': lonmax,
               'ymin': latmin, 'ymax': latmax,
               'dx': res, 'dy': res,
               'nx': nx, 'ny': ny}
    smdict = GeoDict(tmpdict, adjust='bounds')
    print(smdict)

    #---------------------------------------------------------------------------
    # Make rupture context
    #---------------------------------------------------------------------------
    rupt = source.getRuptureContext(gmpes)

    #---------------------------------------------------------------------------
    # Vs30 stuff
    #---------------------------------------------------------------------------
    vs30filename = args.vs30
    vs30grid = GMTGrid.load(vs30filename, smdict, resample=True)
    vs30geodict = vs30grid.getGeoDict()

    # Sites object
    sites = Sites(vs30grid)
    sx = sites.getSitesContext()

    # Clip Vs30 do avoid interpolation error
    sx.vs30 = np.clip(sx.vs30, 0, 2000)

    #---------------------------------------------------------------------------
    # Standard deviation stuff
    #---------------------------------------------------------------------------

    # Only use total standard deviation for scenarios since
    # we never have data to get bias.
    stddev_types = [const.StdDev.TOTAL]

    #---------------------------------------------------------------------------
    # Intensity measures (excluding MI)
    #---------------------------------------------------------------------------

    # Mapping between the IM notation in ShakeMap and the
    # OpenQuake notation for the IMs taht we want
    imt_dict = {'pga': 'PGA', 'pgv': 'PGV', 'psa03': 'SA(0.3)',
                'psa10': 'SA(1.0)', 'psa30': 'SA(3.0)'}

    #---------------------------------------------------------------------------
    # Mesh calculations
    #---------------------------------------------------------------------------
    lats = np.linspace(smdict.ymax, smdict.ymin, smdict.ny)
    lons = np.linspace(smdict.xmin, smdict.xmax, smdict.nx)
    lon, lat = np.meshgrid(lons, lats)
    dep = np.zeros_like(lon)

    # Compute distances and site parameters on mesh.
    dist = Distance(gmpes, source, lat, lon, dep)
    dx = dist.getDistanceContext()

    #---------------------------------------------------------------------------
    # Intensity measure calculation
    #---------------------------------------------------------------------------

    # Make a dictionary to store intensity measure(s) and
    # their sigmas.

    orig_shape = sx.vs30.shape
    imdict = {'pga': {'mean': np.zeros(orig_shape),
                      'sigma': np.zeros(orig_shape)},
              'pgv': {'mean': np.zeros(orig_shape),
                      'sigma': np.zeros(orig_shape)},
              'psa03': {'mean': np.zeros(orig_shape),
                        'sigma': np.zeros(orig_shape)},
              'psa10': {'mean': np.zeros(orig_shape),
                        'sigma': np.zeros(orig_shape)},
              'psa30': {'mean': np.zeros(orig_shape),
                        'sigma': np.zeros(orig_shape)}}

    #---------------------------------------------------------------------------
    # Directivity
    #---------------------------------------------------------------------------
    if event['directivity'] is True:
        R13 = Rowshandel2013.fromSites(
            source, sites, dx=1.0, T=[1.0, 3.0],
            a_weight=0.5, mtype=1)
        fd1 = R13.getFd()[0]
        fd3 = R13.getFd()[1]

    #---------------------------------------------------------------------------
    # Evaluarte GMPEs
    #---------------------------------------------------------------------------
    for key, val in imt_dict.items():
        iimt = imt.from_string(val)

        # Remove those GMPEs that are not applicable to this IMT and redistribute
        # the weights. 
        sgmpe, swts = filter_gmpe_list(gmpes, wts, iimt)

        mgmpe = MultiGMPE.from_list(sgmpe, swts,
                                    default_gmpes_for_site = site_gmpes)
        lnmu, lnsd = mgmpe.get_mean_and_stddevs(
            sx, rupt, dx, iimt, stddev_types)

        # If large distance weights are given, calculate those distances
        if (wts_large_dist is not None) and (np.max(dx.rjb) > dist_cutoff):
            sgmpe_large, swts_large = filter_gmpe_list(gmpes, wts_large_dist, iimt)
            mgmpe_large = MultiGMPE.from_list(
                sgmpe_large, swts_large, default_gmpes_for_site = site_gmpes)
            lnmu_large, lnsd_large = mgmpe_large.get_mean_and_stddevs(
                sx, rupt, dx, iimt, stddev_types)

            # Stomp on lnmu and lnsd at large distances
            dist = dx
            lnmu[dx.rjb > dist_cutoff] = lnmu_large[dx.rjb > dist_cutoff]
        
        #-----------------------------------------------------------------------
        # Handle directivity factors
        # NOTE: currently, the Rowshandel model does not provide
        #       equations for adjusting sigma. Asssuming these are
        #       eventually available, need to move the sigma
        #       adjustment into this if-statement.
        #-----------------------------------------------------------------------
        if event['directivity'] is True:
            if (key == 'pgv') | (key == 'psa10'):
                fd = fd1
            elif (key == 'psa30'):
                fd = fd3
            else:
                # no directivity for pga and psa03
                fd = 0

            lnmu = lnmu + fd

        # Put into intensity measure dictionary
        imdict[key]['mean'] = lnmu
        imdict[key]['sigma'] = lnsd[0]

        #-----------------------------------------------------------------------
        # Write files
        #-----------------------------------------------------------------------

        # Loop over intensity dictionary (PGA PGV, PSA03, PSA10, PSA30)
        for key, val in imdict.items():
            if key != 'pgv':
                # Note that the output is in units of ln(g), whereas
                # ShakeMap wants %g
                mgrid = GMTGrid(100 * np.exp(imdict[key]['mean']), smdict)
                sgrid = GMTGrid(imdict[key]['sigma'], smdict)
            else:
                mgrid = GMTGrid(np.exp(imdict[key]['mean']), smdict)
                sgrid = GMTGrid(imdict[key]['sigma'], smdict)
            mgrid.save(os.path.join(input_dir, key + '_estimates.grd'))
            sgrid.save(os.path.join(input_dir, key + '_sd.grd'))

        # Also write directivity factors to a file
        if event['directivity'] is True:
            fd1grd = GMTGrid(fd1, smdict)
            fd3grd = GMTGrid(fd3, smdict)
            fd1grd.save(os.path.join(input_dir, 'fd1.grd'))
            fd3grd.save(os.path.join(input_dir, 'fd3.grd'))

    #---------------------------------------------------------------------------
    # MMI - Use VirtualIPE
    #---------------------------------------------------------------------------
    gmice = WGRW12()
    vipe = VirtualIPE.fromFuncs(mgmpe, gmice)
    mmi,mmi_sd = vipe.get_mean_and_stddevs(sx, rupt, dx, imt.MMI(), stddev_types)

    mgrid = GMTGrid(mmi, smdict)
    sgrid = GMTGrid(mmi_sd[0], smdict)
    mgrid.save(os.path.join(input_dir, 'mi_estimates.grd'))
    sgrid.save(os.path.join(input_dir, 'mi_sd.grd'))


if __name__ == '__main__':
    desc = '''
    Create the ShakeMap *_estimates.grd and *_sd.grd files. Requires an input 
    directory with event.xml and fault files; the inputs should be created by
    the 'mkinputdir' script or similar. 

    Currently any GMPE set besides NSHMP14acr (or any combination of its 
    constituent GMPEs) is likely to cause errors. 
    '''
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument(
        '-e', '--event',
        help='Specifies the id of the event to process.')
    parser.add_argument(
        '-v', '--vs30',
        help='Specifies the path to the Vs30 grid to use.')
    parser.add_argument(
        '-g', '--gmpe', default='NSHMP14shallow',
        help='Select GMPE(s). Note that NSHMP14shalllow automatically selects '\
             'between NSHMP14acr, NSHMP14scr_rlme, and NSHMP14scr_grd, but '\
             'this currently only works in US.',
        choices=[
            'NSHMP14shallow', 
            'NSHMP14acr', 'NSHMP14scr_rlme', 'NSHMP14scr_grd',
            'NSHMPsub_i', 'NSHMPsub_s'])
    parser.add_argument(
        '-r', '--res', default=30/60/60, type=float,
        help='The resolution in decimal degrees; default is 30/60/60.')
    parser.add_argument(
        '-m', '--max', default=500000, type=int,
        help='Maximum number of cells allowed; '
        'resolution is adjusted to ensure this number is not exceeded; '
        'default is 500,000.')
    shakehome = os.path.join(os.path.expanduser('~'), 'ShakeMap')
    parser.add_argument(
        '-s', '--shakehome',
        help='the location of ShakeMap install; default is %s.' % shakehome)
    args = parser.parse_args()
    main(args)
